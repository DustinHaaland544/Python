Generators in Python are a type of iterable, similar to lists or tuples, but they are defined using a special syntax and provide a way to generate values on the 
fly, one at a time, rather than creating and storing all values in memory at once. Generators are a fundamental concept in Python's support for lazy evaluation 
and are used to create iterators efficiently. They are defined using functions or generator expressions.

Here's a basic overview of generators, their purpose, and the functionality they offer:

Lazy Evaluation: Generators allow us to generate values on-the-fly as we iterate over them, rather than generating and storing all values in memory upfront. This 
is especially useful when dealing with large datasets or infinite sequences.

Memory Efficiency: Since generators generate values one at a time, they are memory-efficient compared to creating lists or other data structures that store all 
values in memory.

Syntax: Generators can be defined using functions that contain one or more yield statements or using generator expressions, which have a similar syntax to list
comprehensions but use parentheses instead of square brackets.

Iteration: We can iterate over the values generated by a generator using a for loop or by using the next() function. Generators automatically remember their state,
so you can continue iterating from where you left off.

Here's an example of a generator function:

def simple_generator():
    yield 1
    yield 2
    yield 3

gen = simple_generator()

for value in gen:
    print(value)

Output:

1
2
3

And here's an example of a generator expression:

gen = (x ** 2 for x in range(5))

for value in gen:
    print(value)

Output:

0
1
4
9
16

Generators are commonly used when dealing with large datasets, streaming data, or when we need to generate an infinite sequence of values (e.g., Fibonacci sequence)
without consuming excessive memory. They provide a powerful way to work with data efficiently in Python.

Generator expressions in Python are concise and memory-efficient ways to create generator objects, which are a type of iterable. They are similar in syntax to list 
comprehensions but use parentheses () instead of square brackets []. Generator expressions are often used when we want to generate values lazily, one at a time, 
without creating a full list in memory.

Here's the basic syntax of a generator expression:

(expression for variable in iterable if condition)

expression: This is the expression that defines how each item in the generator will be computed.

variable: This represents a variable that takes on each value from the iterable one at a time.

iterable: It can be any iterable (e.g., a list, tuple, string, or another generator) that provides values for the variable.

condition (optional): We can include an optional condition to filter values from the iterable. Only items that satisfy the condition will be included in the
generator.

Generator expressions are particularly useful when working with large datasets or when you want to produce values on-the-fly without storing them in memory. 
They provide a memory-efficient alternative to list comprehensions.

Here are some examples of generator expressions:

Creating a generator that yields squares of numbers from 1 to 5:

gen = (x ** 2 for x in range(1, 6))

Generating a sequence of even numbers between 0 and 10:

even_numbers = (x for x in range(11) if x % 2 == 0)

Filtering and transforming a list of names:

names = ["Alice", "Bob", "Charlie", "David"]
filtered_names = (name.upper() for name in names if len(name) > 4)

Generator expressions are typically used in places where you would iterate over values one at a time, such as in for loops, function arguments that accept 
iterables, and wherever lazy evaluation is preferred to save memory and improve performance.
